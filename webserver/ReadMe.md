# webserver
## 1. locker.h
代码实现了对线程同步机制的封装，主要用于多线程编程中的同步和互斥操作。
这些同步机制的封装使得多线程编程更加简单和高效，避免了直接使用底层 API 导致的错误和不便。同时也提高了代码的可读性、可维护性和可移植性。

**locker 类**：提供互斥锁的封装，保证在多线程环境下访问共享资源的安全性。
包括构造函数初始化互斥锁、析构函数销毁互斥锁、lock() 上锁、unlock() 解锁和 get() 获取互斥锁对象的地址

**cond 类**：提供条件变量的封装，用于多个线程之间的协调和通信，可以实现线程的等待、唤醒和广播等功能。
包括构造函数初始化条件变量、析构函数销毁条件变量、wait() 等待条件变量、timedwait() 带超时等待条件变量、
signal() 发送条件变量信号和 broadcast() 广播条件变量信号。

**sem 类**：提供信号量的封装，用于解决资源竞争问题，在多线程共享资源时，通过控制信号量来实现线程间的同步和互斥。
包括构造函数初始化信号量、析构函数销毁信号量、wait() 等待信号量和 post() 发送信号量。

## 2. threadpool.h
一个线程池的实现，整个线程池的实现可以方便地在多线程编程中管理和调度任务，提高程序的效率和稳定性,
其中定义了一个模板类 threadpool，模板参数T是任务类。具体包含以下内容：

**构造函数**：初始化线程池大小和最大请求队列长度，并为每个工作线程创建线程并设置为脱离状态。
**析构函数**：销毁线程池，同时设置 m_stop 标记为 true 表示结束线程。
**append() 函数**：向工作队列中添加任务，并通过信号量来通知有任务需要处理。如果队列已满则添加任务失败。
**worker() 函数**：线程池中所有工作线程的入口函数，调用 run() 函数来处理任务。
**run() 函数**：从工作队列中获取任务并执行，如果队列为空则等待。该函数包含以下操作：
1. 等待信号量 m_queuestat 的触发，即是否有任务需要处理。
2. 使用互斥锁 m_queuelocker 来保护工作队列，避免多个线程同时访问队列导致数据不一致。
3. 获取队首任务并弹出，然后释放互斥锁，开始对任务进行处理。
4. 如果获取到的任务为空，则跳过本次循环继续下一次等待。
5. 否则，调用任务的 process() 函数来处理任务。
此外，还使用了自己实现的 locker 类和 sem 类封装了互斥锁和信号量等同步机制，以确保线程安全性和避免竞态条件。

## 3. http_conn.h
这段代码是一个 HTTP 服务器基于 epoll I/O 复用模型的实现，定义了一个 http_conn 类。该类包括以下成员变量和函数：

m_epollfd：所有的 socket 事件都被注册到同一个 epoll 对象上。
m_user_count：统计用户的数量。
m_sockfd：该 http 连接的 socket。
m_address：通信的 socket 地址。

函数包括：
process()：处理客户端的请求。
init()：初始化新接收的连接。
close_conn()：关闭连接。
read()：非阻塞的读。
write()：非阻塞的写。

##3. http_conn.cpp (commit at 03/14)
这段代码是一个简单的基于Epoll多路复用模型的HTTP服务器的实现，主要包含以下内容：
1.定义了全局变量 m_epollfd 作为所有 socket 事件都被注册到同一个 epoll 对象上的文件描述符；另外定义 m_user_count 统计连接上的用户数量。
2.封装了一些常用操作函数，如设置文件描述符非阻塞、添加文件描述符到 epoll 中、从 epoll 中删除文件描述符、修改 epoll 文件描述符等。
3.初始化连接：将 client 的 sockfd 添加到 epoll 对象中，并开启 EPOLLONESHOT 模式（只监听一次事件），同时记录连接数。
4.关闭连接：从 epoll 对象中删除 sockfd，关闭 client 的 fd，并更新连接数。
5.实现了读和写方法，这里的读和写是非阻塞的，因此它们只会一次性地读或写完数据。
6.process() 是处理 HTTP 请求的入口函数。在这个例子中，通过解析 HTTP 请求和生成响应来处理客户端请求。

这段代码并没有展示完整的 HTTP 协议实现细节，只是提供了一个基本的框架来理解 HTTP 服务器的工作流程。